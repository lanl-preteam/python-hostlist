#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# rewrite of dshbak using python-hostlist

__version__ = "#VERSION#"

# Copyright (C) 2010 Mattias Slabanja <slabanja@chalmers.se>
#               
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301, USA.

import sys
import optparse
import re

from hostlist import collect_hostlist, expand_hostlist, __version__ as library_version
from difflib import unified_diff, SequenceMatcher 
from itertools import count

def scan():
    """Scan stdin, store lines by host, and return it all in a
    dictionary indexed by host.

    Input lines are expected to be on the format
    "<hostname>:<rest of line>". Lines not matching that format
    are added to the dictionary using None as key.

    The linesplit-re is designed to match the original dshbak behavior. 
    """

    linesplitter = re.compile(r'^ *([A-Za-z0-9.-]+) *: ?(.*)$')
    text_dict = {}

    for line in sys.stdin:
        match = linesplitter.match(line)
        if match:
            host, hostline = match.groups()
        else:
            # The linesplitter regexp did NOT match.
            # This line will be added to text_dict[None]
            host = None
            hostline = line.rstrip('\n')

        if host in text_dict:
            # The groups in the linesplitter regexp does not include the trailing '\n'
            text_dict[host] += "\n" + hostline
        else:
            text_dict[host] = hostline

    return text_dict

def collect(text_dict):
    """Collect hosts having identical output.

    Return a list of (host set, text) tuples."""

    reverse_dict = {}
    for host, text in text_dict.iteritems():
        if text in reverse_dict:
            reverse_dict[text].add(host)
        else:
            reverse_dict[text] = set((host,))

    return [(host_set, text) for text, host_set in reverse_dict.iteritems()]

def output(host_set_or_str, text, count_hosts = False):
    """Prepend the output with a hostname framed with horizontal lines."""
    hline = '-' * 16
    if isinstance(host_set_or_str, str):
        header = host_set_or_str # for the benefit of the garbage header
    else:
        header = collect_hostlist(host_set_or_str)
        if count_hosts:
            header = "%d: %s" % (len(host_set_or_str),  header)
    print hline
    print header
    print hline
    print text


def in_red(s):
    return '\033[91m' + s + '\033[0m'

class Collector:
    """Collect relatively matching texts, find similarities and differences

    Depends on SequenceMatcher. 
    Texts being similar enough when doing a line-per-line comparison
    to a reference text can be added with the try_add_text method.
    When texts of interest has been added, calling the process method
    will sort out which parts are identical (per line intersection 
    of all matches between reference and rest of the texts)
    and will store the individual differences.
    The heavy part of the processing is done by
    SequenceMatcher.get_matching_blocks called from try_add_text.
    """
    def __init__(self, ref_text, label=None, match_limit=0.5):
        ref_lines = ref_text.split('\n')
        self._N = len(ref_lines)
        self._matchers = [SequenceMatcher(None, L, L) for L in ref_lines]
        assert match_limit <= 1.0 and match_limit >= 0
        self._match_limit = match_limit
        self._lmb_pairs = [[] for i in range(self._N)]
        self._labels = []
        self._label_counter = count(1)

        self._reset_processing_result()
        self._add_lines(ref_lines)
        self._push_label_name(label)

    def try_add_text(self, text, label=None):
        lines = text.split('\n')
        if len(lines) != self._N:
            return False

        self._update_seq1(lines)

        ratio = (1.0/self._N) * sum([mat.quick_ratio() for mat in self._matchers])
        if ratio < self._match_limit:
            return False

        self._reset_processing_result()
        self._add_lines(lines)
        self._push_label_name(label)
        return True

    def process(self):
        for label in self._labels:
            self._diffs[label] = []

        for i in range(self._N):
            self._process_line(i)

        self.text = '\n'.join(self._text_lines)
        self.labels = self._labels
        self.N_diffs = self._diff_counter.next()-1

    def _update_seq1(self, lines):
        for L, mat in zip(lines, self._matchers):
            mat.set_seq1(L)

    def _reset_processing_result(self):
        self.text = None
        self.labels = None
        self.N_diffs = None
        self.diffs = None
        self._text_lines = [''] * self._N
        self._diff_counter = count(1)
        self._diffs = {}

    def _add_lines(self, lines):
        # Add a new set of lines, matchers seq1 must already be updated
        for lmbs, L, mat in zip(self._lmb_pairs, lines, self._matchers):
            lmbs.append((L, mat.get_matching_blocks())) #This is what's taking time
        
    def _push_label_name(self, label=None):
        if label is None:
            self._labels.append('text%i' % self._label_counter.next())
        else:
            self._labels.append(label)
            
    def _process_line(self, line_i):
        # Process a given line number (ith line for all texts).
        # * Using a mask, construct a "minimum match"
        # * Sort out "minumum match"/"supremum non-match" into
        #   matching-blocks-like format
        # * Construct an output text line with "diff-labels"
        #   as placeholders for non-matches
        # * Sort out the differences (if any) and add them to
        #   a list for the respective label/host 

        lmbs = self._lmb_pairs[line_i]
        ref_L, _ = lmbs[0]
        ref_L_N = len(ref_L)
        part_mask = [1] * (ref_L_N+1) #Extra element to indicate trailing diff
        for _, mb in lmbs[1:]: #Next matching-block
            ipn = jpn = 0
            for i, j, n in mb:
                if ((i != 0 or j != 0) and
                    (jpn != j or ipn != i)):
                    #There is a diff, update the partion mask
                    for jind in range(jpn, j):
                        part_mask[jind] = False
                    for jind in range(j, ref_L_N+1):
                        if part_mask[jind]:
                            part_mask[jind] += 1
                jpn = j + n
                ipn = i + n
        part_mask, end_part = part_mask[:-1], part_mask[-1]

        # collect combined non- and minimal- matching blocks between
        # the reference line and all other lines into one.
        # 'n' = non-matching, 'm' = matching.
        # non-matching blocks can be 0-length.
        nm_mb = []
        opj = 0
        op = 1
        
        for j in range(0, ref_L_N):
            if part_mask[j] is False:
                if op is False:
                    # Continue along non-matching block
                    continue
                elif j-opj > 0:
                    # from matching to non-matching block
                    nm_mb.append(('m', opj, j-opj))
            else:
                if part_mask[j] == op:
                    # Continue along matching block
                    continue
                elif op is False:
                    # from non-matching to matching block
                    nm_mb.append(('n', opj, j-opj))
                else:
                    # go between matching (via 0-length non-matching)
                    if j-opj > 0:
                        nm_mb.append(('m', opj, j-opj))
                    nm_mb.append(('n', j, 0))
            op = part_mask[j]
            opj = j

        if op is False:
            nm_mb.append(('n', opj, ref_L_N-opj))
        else:
            nm_mb.append(('m', opj, ref_L_N-opj))
            if op != end_part:
                nm_mb.append(('n', ref_L_N, 0))


        if len(nm_mb) == 1 and nm_mb[0][0] == 'm':
            #Only a single matching-block, hence no diffs among the set of lines
            self._text_lines[line_i] = ref_L
            return

        line = []
        for t, j, n in nm_mb:
            if t == 'm':
                line.append(ref_L[j:j+n])
            elif t == 'n':
                line.append(in_red('[DIFF%i]' % self._diff_counter.next()))
        self._text_lines[line_i] = ''.join(line)

        index = [-1]*(ref_L_N+2)
        padded_mb = [('m', 0, 0)] + nm_mb + [('m', ref_L_N, 0)]
        for label, lmb in zip(self._labels, lmbs):
            L, mb = lmb
            index[ref_L_N] = len(L)
            for i, j, n in mb:
                index[j:j+n] = range(i, i+n)

            diffs = self._diffs[label]
            for mb_i in range(1, len(padded_mb)-1):
                if padded_mb[mb_i][0] == 'n':
                    _, jA, nA = padded_mb[mb_i-1]
                    _, jB, _  = padded_mb[mb_i+1]
                    iA = index[jA+nA-1]+1        
                    iB = index[jB]
                    diffs.append(L[iA:iB])
                    
            

# MAIN

op = optparse.OptionParser(usage="usage: %prog [OPTION]...",
                           add_help_option = False)

op.add_option("-c", "--collect", action="store_true",
              help="Collect identical output.")
op.add_option("-C", "--collect-similar", action="store_true",
              help="Collect similar output. Collects output that is "
              "in relatively close proximity to each other. ")
op.add_option("", "--show-diff", action="store_true",
              help="When using --collect-similar, also print the "
              "individual differences for each host.")
op.add_option("", "--show-only-diff", action="store_true",
              help="When using --collect-similar, the same as "
              "--show-diff, but don't display "
              "the identical part of the texts.")

op.add_option("-n", "--count", action="store_true",
              help="Show the number of hosts in the header.")

op.add_option("-d", "--unified-diff", action="store_true",
              help="Print the most frequent output in its full form, "
              "and all other outputs as unified diffs "
              "relative the most frequent output. This option implies --collect.")

op.add_option("-g", "--with-garbage", action="store_true",
              help="Also collect and print input not conforming to the "
              ' "host : output"-format. '
              "Garbage output will be presented separated from host output.")

op.add_option("-h", "--help", action="help", help="Show help")
op.add_option("--version",
              action="store_true",
              help="Show version")

(opts, args) = op.parse_args()

if opts.version:
    print "Version %s (library version %s)" % (__version__, library_version)
    sys.exit()

try:
    text_dict = scan()

    if opts.with_garbage and None in text_dict:
        # The user wants to see garbage-output, and it is non-empty.
        # Print it before the host output regardless of diff/normal mode.
        output('NON-FORMATTED OUTPUT', text_dict[None])
    # Remove garbage lines from text_dict
    text_dict.pop(None,None)

    if opts.unified_diff:
        # "Unified diff mode", print the most abundant output, O, in full, and all
        # other outputs as a unified diff relative O.

        hosts_text_list = collect(text_dict)

        # Sort in descending order of the number of hosts
        hosts_text_list.sort(key = lambda x: -len(x[0]))

        if len(hosts_text_list) == 0:
            sys.exit()

        # The most abundant output
        ref_host_set, ref_text = hosts_text_list.pop(0)
        ref_hostlist = collect_hostlist(ref_host_set)

        # Split into lines for use with difflib.
        ref_lines = ref_text.split('\n')

        output(ref_host_set, ref_text, opts.count)

        for host_set, text in hosts_text_list:
            output(host_set,
                   '\n'.join(unified_diff(ref_lines,
                                          text.split('\n'),
                                          fromfile=ref_hostlist,
                                          tofile=collect_hostlist(host_set),
                                          lineterm='')),
                   opts.count)

    elif opts.collect_similar:

        collects = []
        for host, text in text_dict.iteritems():
            picked = False
            for c in collects:
                picked = c.try_add_text(text, host)
                if picked:
                    break
            if not picked:
                collects.append(Collector(text, host))
            
        for c in collects:
            c.process()
            if not opts.show_only_diff:
                output(set(c._labels), c.text, opts.count)
            if opts.show_diff or opts.show_only_diff:
                for h in c._labels:
                    print (("%s: " % h) +
                           ' '.join(['"'+x+'"' for x in c._diffs[h]]))

    else:
        # "Normal" mode, just print the output

        if opts.collect:
            hosts_text_list = collect(text_dict)
        else:
            hosts_text_list = [(set((n,)), l) for n,l in text_dict.iteritems()]

        # Sort in descending order of the number of hosts
        hosts_text_list.sort(key = lambda x: -len(x[0]))

        for host_set, text in hosts_text_list:
            output(host_set, text, opts.count)

except KeyboardInterrupt:
    sys.exit()

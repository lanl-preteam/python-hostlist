#!/usr/bin/env python

import sys
import optparse
import stats
from hostlist import collect_hostlist

# clean and refine indata: list of STRING -> list of [ "hostname", float vaule ]
def refine_data(rawlist):
    if opts.verbose:
        print "Info: read in %i lines of data" % len(rawlist)

    # Transform additional separators -> " "
    for char in opts.field_separators:
        if opts.verbose:
            print "Info: adding additional field separator: \"%s\"" % char
        for i in range(len(rawlist)):
            tmp = rawlist[i].replace(char, " ")
            rawlist[i] = tmp

    if not opts.key:
        # list to hold candidates for KEY
        key = []
        # Lets have a look at the last three lines
        for lnum in range(len(rawlist)-3,len(rawlist)):
            sline = rawlist[lnum].strip().split()
            if len(sline) < 2:
                key.append(0)
                continue
            # The first column that can be converted to a float will be our candidate
            for i in [ x + 1 for x in range(len(sline[1:])) ]:
                tmp = None
                try:
                    tmp = float(sline[i])
                except ValueError:
                    pass
                if tmp != None:
                    if opts.verbose:
                        print "Info: auto-detect row=%i found data at column %i" % (lnum, i)
                    key.append(i)
                    break
        if opts.verbose:
            print "Info: key list after auto-detect: %s" % str(key)

        # If more than half of the investigated lines have the same candidate...
        for candidate in key:
            if key.count(candidate) == len(key):
                opts.key = candidate
                if opts.verbose:
                    print "Info: auto-detect unanimously selected key: %i" % candidate
                break
            if key.count(candidate) > (len(key) / 2):
                opts.key = candidate
                if opts.verbose:
                    print "Info: auto-detect selected key: %i by majority choice" % candidate
                break
        
        # No winner found (or winner was 'bad line')
        if not opts.key or (opts.key == 0):
            print "Error: Unable to auto-detect KEY from data"
            exit(1)

    cleandata = []
    for line in rawlist:
        sline = line.strip().split()
        tmp = None
        try:
            tmp = float(sline[opts.key])
        except ValueError:
            pass
        if tmp != None:
            cleandata.append([ sline[0].strip(":"), tmp ])
        else:
            if opts.verbose:
                print "Info: rejected line: \"%s\"" % line.strip()

    return cleandata

def create_merged_buckets(valuelist):
    pass

def create_custom_buckets(valuelist):
    pass

# remove duplicate values from a list
# does not work properly, why not?
def dedupe(l):
    newlist = []
    seen = set()
    for v in l:
        if not v in seen:
            newlist.append(v)
            seen.add(v)
    return newlist

# Bucket creation function
def create_buckets(valuelist):
    minvalue = valuelist[0]
    maxvalue = valuelist[-1]
    # size of range
    rsize = maxvalue - minvalue
    # initial bucket size
    bsize = rsize / opts.nbuckets
    # number of forced buckets
    nforce = 0

    if opts.verbose:
        print "Info: smallest value found was %.2f" % minvalue
        print "Info: largest value found was %.2f" % maxvalue

    blist = []
    # -m passed, lets look for large pieces of range with same value
    if opts.merge_buckets:
        if opts.verbose:
            print "Info: Creating buckets around empty regions (--merge-buckets)"
#        blist = create_merged_buckets(valuelist)
        # how much of rsize has been covered so far
        comprange = 0
        deduped_vlist = dedupe(valuelist)
        # for each unique value check distance to next value, create bucket if large enough
        for nval in xrange(len(deduped_vlist)-1):
            if deduped_vlist[nval+1]-deduped_vlist[nval] > bsize:
                blist.append( { 'ub': deduped_vlist[nval], 'alsolb': 1} )
                blist.append( { 'ub': deduped_vlist[nval+1] } )
                comprange += deduped_vlist[nval+1]-deduped_vlist[nval]
                nforce += 1
        # sort blist and add end bucket at maxvalue
        blist.sort(lambda a, b: cmp(a['ub'], b['ub']))
        blist.append( { 'ub': maxvalue } )
        # figure out how much work we have left
        remainingrange = rsize - comprange
        remainingbuckets = opts.nbuckets - nforce
        remainingbsize = remainingrange / remainingbuckets
        if opts.verbose:
            print "Info: remaining range is targeted at %i buckets" % remainingbuckets
            print "Info: remaining range: %.2f -> bsize: %.2f" % (remainingrange,
                                                                  remainingbsize)
        # traverse buckets and see if what's below can/should be split
        for bnum in xrange(len(blist)):
            if bnum == 0:
                lowref = minvalue
            else:
                lowref = blist[bnum-1]['ub']
                if 'alsolb' in blist[bnum-1]:
                    continue
#            print "candidate range: %.2f to %.2f" % (lowref, blist[bnum]['ub'])
#            print "1.3 x remainingbsize for this range: %.2f" % ((blist[bnum]['ub']-lowref) / (1.3 * remainingbsize))
            # 1.3 purely made up but seems quite good ;-)
            nnew = int((blist[bnum]['ub'] - lowref) / (1.3 * remainingbsize))
            if nnew > 0:
                newbsize = (blist[bnum]['ub'] - lowref) / (nnew + 1)
#                print "newbsize: %.2f" % newbsize
                for x in xrange(nnew):
                    if opts.verbose:
                        print "Info: adding additional bucket at: %.2f" % (lowref + (newbsize * (x + 1)))
                    blist.append( {'ub': lowref + (newbsize * (x + 1)) })
        # finish up with a final sort
        blist.sort(lambda a, b: cmp(a['ub'], b['ub']))
    elif opts.bucket:
        if opts.verbose:
            print "Info: Creating buckets based on custom data"
#        blist = create_custom_buckets(valuelist)
        # how much of rsize has been covered so far
        comprange = 0
        for b in opts.bucket:
            # parse the given explicit bucket(s)
            try:
                (lb, ub) = map(float, b.replace("-", " ").split())
            except:
                print "Error: Incorrect bucket format specified."
                exit(1)
            if opts.verbose:
                print "Info: adding bucket from commandline: %.2f - %.2f" % (lb, ub)
            blist.append( { 'ub': lb, 'alsolb': 1 } )
            blist.append( { 'ub': ub } )
            comprange += ub - lb
            nforce += 1
        blist.sort(lambda a, b: cmp(a['ub'], b['ub']))
        blist.append( { 'ub': maxvalue } )
        # figure out how much work we have left
        remainingrange = rsize - comprange
        remainingbuckets = opts.nbuckets - nforce
        remainingbsize = remainingrange / remainingbuckets
        if opts.verbose:
            print "Info: remaining range is targeted at %i buckets" % remainingbuckets
            print "Info: remaining range: %.2f -> bsize: %.2f" % (remainingrange,
                                                                  remainingbsize)
        # traverse buckets and see if what's below can/should be split
        for bnum in xrange(len(blist)):
            if bnum == 0:
                lowref = minvalue
            else:
                lowref = blist[bnum-1]['ub']
                if 'alsolb' in blist[bnum-1]:
                    continue
#            print "candidate range: %.2f to %.2f" % (lowref, blist[bnum]['ub'])
#            print "1.3 x remainingbsize for this range: %.2f" % ((blist[bnum]['ub']-lowref) / (1.3 * remainingbsize))
            # 1.3 purely made up but seems quite good ;-)
            nnew = int((blist[bnum]['ub'] - lowref) / (1.3 * remainingbsize))
            if nnew > 0:
                newbsize = (blist[bnum]['ub'] - lowref) / (nnew + 1)
#                print "newbsize: %.2f" % newbsize
                for x in xrange(nnew):
                    if opts.verbose:
                        print "Info: adding additional bucket at: %.2f" % (lowref + (newbsize * (x + 1)))
                    blist.append( {'ub': lowref + (newbsize * (x + 1)) })
        # finish up with a final sort
        blist.sort(lambda a, b: cmp(a['ub'], b['ub']))
    else:
        if opts.verbose:
            print "Info: Creating simple linear bucket set"
        # simple linear bucket creation
        done = minvalue
        for bnum in xrange(opts.nbuckets):
            tmp = {}
            tmp['ub'] = done + bsize
            done = done + bsize
            blist.append(tmp)

    return blist


##
### Main program
##        

optp = optparse.OptionParser(usage="usage: %prog [options] < DATA")
optp.add_option("-b", "--bucket",
                action="append", type="string", metavar="LOW-HI",
                help="explicitly specify a bucket (option may be give more than once)")
optp.add_option("-k", "--key",
                action="store", type="int", default=None,
                help="use data at position KEY (default: auto)")
optp.add_option("-m", "--merge-buckets",
                action="store_true", default=False,
                help="adaptively merge buckets when possible (default: False)")
optp.add_option("-n", "--nbuckets",
                action="store", type="int", default=5,
                help="number of buckets to use (default: %default)")
optp.add_option("-s", "--statistics",
                action="store_true", default=False,
                help="include a statistic summary")
optp.add_option("-S", "--chop-long-lines",
                action="store_true", default=False,
                help="chop too long lines / enforce one output line per bucket")
optp.add_option("-t", "--field-separators",
                action="store", type="string", default="",
                help="_additional_ field separators (default: \"\")")
optp.add_option("-v", "--verbose",
                action="store_true", default=False)
optp.add_option("--debug",
                action="store_true", default=False)
(opts, args) = optp.parse_args(sys.argv[1:])

if args != []:
    optp.print_help()
    sys.exit(1)

if opts.nbuckets < 1:
    print "Error: number of buckets must be a positive integer"
    exit(1)

rawdata = sys.stdin.readlines()

if len(rawdata) <= 3:
    print "Error: not enough indata (only %i line(s))" % len(rawdata)
    exit(1)

data = refine_data(rawdata)
data.sort(lambda a, b: cmp(a[1], b[1]))

if opts.verbose:
    print "Info: cleaned up data: %s" % str(data)

valuelist = map(lambda(x): x[1], data)
valuelist.sort()

buckets = create_buckets(valuelist)

if opts.statistics:
    print "Statistical summary"
    print "-" * 50
    print " Number of values: %i" % len(valuelist)
    print " Min value: %f" % valuelist[0]
    print " Max value: %f" % valuelist[-1]
    print " Mean: %f" % stats.mean(valuelist)
    print " Median: %f" % stats.median(valuelist)
    print " Standard deviation: %f" % stats.stdev(valuelist)
    print " Sum: %f" % stats.sum(valuelist)
    print

for nbucket in xrange(len(buckets)):
    buckets[nbucket]['nodelist'] = []
    
currentbucket = 0
for (node, value) in data:
    while (buckets[currentbucket]['ub'] < value):
        currentbucket += 1
#        print "bumping bucket number..."
    buckets[currentbucket]['nodelist'].append(node)
#    print "%i: adding %s %.2f" % (currentbucket, node, value)

lower = valuelist[0]
for bucket in buckets:
    print "%.2f-%.2f: %i %s" % (lower,
                                bucket['ub'],
                                len(bucket['nodelist']),
                                collect_hostlist(bucket['nodelist']))
    lower = bucket['ub']

#ncharvalue = max(len(str(maxvalue)), 3)
#ncharnodecnt = max(len(str(maxnperbucket)), 3)
#
##print "ncharvalue: %i" % ncharvalue
##print "ncharnodecnt: %i" % ncharnodecnt
#
#if opts.verbose:
#    print
#    print "%sLOW-%sHI: %sCNT  HOSTLIST" % (" " * (ncharvalue - 3),
#                                           " " * (ncharvalue - 2),
#                                           " " * (ncharnodecnt - 3))
#    print "-" * 80
#
## Main output print
#for bucket in buckets:
#    pad1 = (ncharvalue - len(str(bucket['start']))) * " "
#    pad2 = (ncharvalue - len(str(bucket['end']))) * " "
#    pad3 = (ncharnodecnt - len(str(len(bucket['nodes'])))) * " "
#    print "%s%i-%s%i: %s%i  %s" % (pad1, bucket['start'],
#                                   pad2, bucket['end'],
#                                   pad3, len(bucket['nodes']),
#                                   collect_hostlist(bucket['nodes']))
